C51 COMPILER V9.60.7.0   MAIN                                                              11/03/2023 18:00:24 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Firmware) DEBUG PRINT(.\L
                    -istings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include  "config.h"
   2          #include  "STC8G_H_ADC.h"
   3          #include  "STC8G_H_GPIO.h"
   4          #include  "STC8G_H_NVIC.h"
   5          #include  "STC8G_H_Switch.h"
   6          #include  "STC8G_H_Delay.h"
   7          #include  "STC8G_H_UART.h"
   8          #include    "math_sensor.h"
   9          
  10          /*Òý½Å¶ÔÓ¦
  11          
  12          ADC²ÉÑùÒý½Å
  13          P3.4  ADC13 ADCA
  14          P1.1  ADC1  ADCB
  15          P3.3  ADC12 ADCC
  16          P1.0  ADC0  ADCD
  17          
  18          XÉ¨ÃèÒý½Å
  19          P1.4  AX1
  20          P1.3  AX2
  21          P1.2  AX3
  22          
  23          LEDÒý½Å
  24          P5.4  LED-W
  25          
  26          ´®¿ÚÒý½Å
  27          P3.0  RX
  28          P3.1  TX
  29          */
  30          
  31          typedef char bool;
  32          
  33          #define LOG_PRINTF 1
  34          
  35          #if LOG_PRINTF
  36          
  37          #else
              typedef struct {
                  uint16_t sof;
                  uint8_t tran_type;
                  uint16_t len;
                  uint8_t type;
                  uint8_t adc_value[12];
                  uint16_t checksum;
              } SerialFrame_t;
              
              #endif
  48          
  49          typedef struct 
  50          {
  51            uint16_t value[3][4];
  52            
  53          #if LOG_PRINTF
  54          #else
C51 COMPILER V9.60.7.0   MAIN                                                              11/03/2023 18:00:24 PAGE 2   

                uint16_t cali_value[3][4];
              #endif
  57          }StuAdcValue;
  58          
  59          typedef enum {
  60            X1 = 1,
  61            X2,
  62            X3
  63          }X_enum;
  64          
  65          typedef enum{
  66            Y1 = 1,
  67            Y2,
  68            Y3,
  69            Y4,
  70          }Y_enum;
  71          
  72          
  73          #define AY1 ADC_CH12
  74          #define AY2 ADC_CH1
  75          #define AY3 ADC_CH0
  76          #define AY4 ADC_CH11
  77          
  78          sbit AX1 = P1^4;
  79          sbit AX2 = P1^3;
  80          sbit AX3 = P1^2;
  81          
  82          sbit LED = P5^4;
  83          
  84          uint32_t time_1ms = 0;
  85          #if LOG_PRINTF
  86          uint8_t printf_buffer[20] = {0};
  87          
  88          #else
              SerialFrame_t serial_frame;
              #endif
  91          
  92          
  93          void ReadAdcValue(StuAdcValue *adc_raw_value);
  94          uint16_t CalChecksum(uint8_t * dat, uint16_t len);
  95          uint16_t big_to_small(uint16_t dat);
  96          
  97          /************************ IO¿ÚÅäÖÃ ****************************/
  98          void  GPIO_config(void)
  99          {
 100   1        GPIO_InitTypeDef  GPIO_InitStructure;         //½á¹¹¶¨Òå
 101   1        GPIO_InitStructure.Pin  = GPIO_Pin_0|GPIO_Pin_1;           //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO_Pin_7, »
             -ò²Ù×÷
 102   1        GPIO_InitStructure.Mode = GPIO_HighZ;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_O
             -D,GPIO_OUT_PP
 103   1        GPIO_Inilize(GPIO_P1,&GPIO_InitStructure);      //³õÊ¼»¯
 104   1      
 105   1        GPIO_InitStructure.Pin  = GPIO_Pin_3|GPIO_Pin_4;         //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO_Pin_7, »ò²
             -Ù×÷
 106   1        GPIO_InitStructure.Mode = GPIO_HighZ;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_O
             -D,GPIO_OUT_PP
 107   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);      //³õÊ¼»¯
 108   1        
 109   1        GPIO_InitStructure.Pin  = GPIO_Pin_0|GPIO_Pin_1;         //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO_Pin_7, »ò²
             -Ù×÷
 110   1        GPIO_InitStructure.Mode = GPIO_OUT_PP;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
             -OD,GPIO_OUT_PP
C51 COMPILER V9.60.7.0   MAIN                                                              11/03/2023 18:00:24 PAGE 3   

 111   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);      //³õÊ¼»¯
 112   1        
 113   1        GPIO_InitStructure.Pin  = GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4;         //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO
             -_Pin_7, »ò²Ù×÷
 114   1        GPIO_InitStructure.Mode = GPIO_OUT_PP;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
             -OD,GPIO_OUT_PP
 115   1        GPIO_Inilize(GPIO_P1,&GPIO_InitStructure);      //³õÊ¼»¯
 116   1        
 117   1        GPIO_InitStructure.Pin  = GPIO_Pin_4;         //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO_Pin_7, »ò²Ù×÷
 118   1        GPIO_InitStructure.Mode = GPIO_PullUp;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
             -OD,GPIO_OUT_PP
 119   1        GPIO_Inilize(GPIO_P5,&GPIO_InitStructure);      //³õÊ¼»¯
 120   1      }
 121          
 122          
 123          /******************* ADÅäÖÃº¯Êý *******************/
 124          void  ADC_config(void)
 125          {
 126   1        ADC_InitTypeDef   ADC_InitStructure;    //½á¹¹¶¨Òå
 127   1      
 128   1        ADC_InitStructure.ADC_SMPduty   = 31;   //ADC Ä£ÄâÐÅºÅ²ÉÑùÊ±¼ä¿ØÖÆ, 0~31£¨×¢Òâ£º SMPDUTY Ò»¶¨²»ÄÜÉèÖÃÐ¡ÓÚ 
             -10£©
 129   1        ADC_InitStructure.ADC_CsSetup   = 0;    //ADC Í¨µÀÑ¡ÔñÊ±¼ä¿ØÖÆ 0(Ä¬ÈÏ),1
 130   1        ADC_InitStructure.ADC_CsHold    = 1;    //ADC Í¨µÀÑ¡Ôñ±£³ÖÊ±¼ä¿ØÖÆ 0,1(Ä¬ÈÏ),2,3
 131   1        ADC_InitStructure.ADC_Speed     = ADC_SPEED_2X16T;    //ÉèÖÃ ADC ¹¤×÷Ê±ÖÓÆµÂÊ ADC_SPEED_2X1T~ADC_SPEED_2X16
             -T
 132   1        ADC_InitStructure.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;  //ADC½á¹ûµ÷Õû,  ADC_LEFT_JUSTIFIED,ADC_RIGHT_JUSTIF
             -IED
 133   1        ADC_Inilize(&ADC_InitStructure);    //³õÊ¼»¯
 134   1        ADC_PowerControl(ENABLE);       //ADCµçÔ´¿ª¹Ø, ENABLE»òDISABLE
 135   1        NVIC_ADC_Init(DISABLE,Priority_0);    //ÖÐ¶ÏÊ¹ÄÜ, ENABLE/DISABLE; ÓÅÏÈ¼¶(µÍµ½¸ß) Priority_0,Priority_1,Prio
             -rity_2,Priority_3
 136   1      }
 137          
 138          
 139          /***************  ´®¿Ú³õÊ¼»¯º¯Êý *****************/
 140          void  UART_config(void)
 141          {
 142   1        COMx_InitDefine   COMx_InitStructure;         //½á¹¹¶¨Òå
 143   1      
 144   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;   //Ä£Ê½,   UART_ShiftRight,UART_8bit_BRTx,UART_9bit,U
             -ART_9bit_BRTx
 145   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;     //Ñ¡Ôñ²¨ÌØÂÊ·¢ÉúÆ÷, BRT_Timer2 (×¢Òâ: ´®¿Ú2¹Ì¶¨Ê¹ÓÃBRT_
             -Timer2, ËùÒÔ²»ÓÃÑ¡Ôñ)
 146   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //²¨ÌØÂÊ,     110 ~ 115200
 147   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //½ÓÊÕÔÊÐí,   ENABLE»òDISABLE
 148   1        UART_Configuration(UART1, &COMx_InitStructure);   //³õÊ¼»¯´®¿Ú2 USART1,USART2,USART3,USART4
 149   1        NVIC_UART1_Init(ENABLE,Priority_1);   //ÖÐ¶ÏÊ¹ÄÜ, ENABLE/DISABLE; ÓÅÏÈ¼¶(µÍµ½¸ß) Priority_0,Priority_1,Pri
             -ority_2,Priority_3
 150   1        UART1_SW(UART1_SW_P30_P31);   //UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44
 151   1      }
 152          
 153          
 154          /************************** Ö÷º¯Êý**********************/
 155          void main(void)
 156          {
 157   1        static bool led_flag = FALSE;
 158   1          StuAdcValue temp_adc_value;
 159   1          int32 adc_value = 0, total_value;
 160   1      
 161   1      
 162   1        uint8_t i = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              11/03/2023 18:00:24 PAGE 4   

 163   1        
 164   1        EAXSFR();
 165   1        GPIO_config();
 166   1        UART_config();
 167   1        ADC_config();
 168   1        EA = 1;
 169   1        
 170   1        while(1)
 171   1        {
 172   2          time_1ms ++;
 173   2              //LEDÉÁË¸
 174   2          if(time_1ms % 5 == 0)
 175   2          {
 176   3            LED = 1;
 177   3          }
 178   2          
 179   2          if(time_1ms % 2000 == 0)
 180   2          {
 181   3            led_flag = !led_flag;
 182   3            LED = 0;
 183   3          }
 184   2          
 185   2      
 186   2          if(time_1ms % 14 == 0)
 187   2          {
 188   3            ReadAdcValue(&temp_adc_value);
 189   3            
 190   3          }
 191   2          if(time_1ms % 14 == 0)
 192   2          {
 193   3       //Êý¾ÝÅÅÁÐ×ª»»
 194   3      #if LOG_PRINTF
 195   3                  //adc_calculation_calibration_once((void *)temp_adc_value.value, (void *)temp_adc_value.cali_v
             -alue, 1, printf_buffer);
 196   3            PrintString1(printf_buffer);
 197   3            sprintf(printf_buffer, "adc_value = %u",temp_adc_value.value[0][0]);
 198   3            PrintString1(printf_buffer);
 199   3            sprintf(printf_buffer, " %u",temp_adc_value.value[1][0]);
 200   3            PrintString1(printf_buffer);
 201   3            sprintf(printf_buffer, " %u  ",temp_adc_value.value[2][0]);
 202   3            PrintString1(printf_buffer);
 203   3      
 204   3                  total_value = temp_adc_value.value[1][0] + temp_adc_value.value[2][0] + temp_adc_value.value[0
             -][0];
 205   3            sprintf(printf_buffer, "total %ld  ", adc_value);
 206   3      
 207   3            PrintString1(printf_buffer);
 208   3        
 209   3            
 210   3                        adc_value =  (1024 - total_value) * 1000 / (uint32_t)temp_adc_value.value[0][0];
 211   3                  sprintf(printf_buffer, "cal = %lld", adc_value);
 212   3            PrintString1(printf_buffer);
 213   3            
 214   3                              adc_value =  (1024 - total_value) * 1000 / (uint32_t)temp_adc_value.value[1][0];
 215   3                  sprintf(printf_buffer, " %lld", adc_value);
 216   3            PrintString1(printf_buffer);
 217   3            
 218   3                              adc_value =  (1024 - total_value) * 1000 / (uint32_t)temp_adc_value.value[2][0];
 219   3                  sprintf(printf_buffer, " %lld\r\n", adc_value);
 220   3            PrintString1(printf_buffer);
 221   3            
 222   3            
C51 COMPILER V9.60.7.0   MAIN                                                              11/03/2023 18:00:24 PAGE 5   

 223   3      //      
 224   3      //            adc_value = 1024 * (uint32_t)temp_adc_value.value[0][0] / (1024 - (total_value - temp_adc_va
             -lue.value[0][0]));
 225   3      //            sprintf(printf_buffer, "cal = %lld\r", adc_value);
 226   3      //      PrintString1(printf_buffer);
 227   3      //      
 228   3      //                  adc_value = 1024 * (uint32_t)temp_adc_value.value[1][0] / (1024 - (total_value - temp_adc
             -_value.value[1][0]));
 229   3      //            sprintf(printf_buffer, " %lld\r", adc_value);
 230   3      //      PrintString1(printf_buffer);
 231   3      //      
 232   3      //                  adc_value = 1024 * (uint32_t)temp_adc_value.value[2][0] / (1024 - (total_value - temp_adc
             -_value.value[2][0]));
 233   3      //            sprintf(printf_buffer, " %lld\r\n", adc_value);
 234   3      //      PrintString1(printf_buffer);
 235   3      #else     
                    serial_frame.sof = 0xa55a;
                    serial_frame.tran_type = 0x01;
                    serial_frame.len = big_to_small(sizeof(serial_frame) - 2);
                    serial_frame.type = 0x01;
              
                    adc_calculation_calibration_once((void *)temp_adc_value.value, (void *)temp_adc_value.cali_value, 0)
             -;
                    
              #if 0            
                    serial_frame.adc_value[0] = temp_adc_value.value[1][0]/4;
                    serial_frame.adc_value[1] = temp_adc_value.value[1][3]/4;
                    serial_frame.adc_value[2] = temp_adc_value.value[1][1]/4;
                    serial_frame.adc_value[3] = temp_adc_value.value[1][2]/4;
                    
                    serial_frame.adc_value[4] = temp_adc_value.value[0][0]/4;
                    serial_frame.adc_value[5] = temp_adc_value.value[0][3]/4;
                    serial_frame.adc_value[6] = temp_adc_value.value[0][1]/4;
                    serial_frame.adc_value[7] = temp_adc_value.value[0][2]/4;
                    
                    serial_frame.adc_value[8] = temp_adc_value.value[2][0]/4;
                    serial_frame.adc_value[9] = temp_adc_value.value[2][3]/4;
                    serial_frame.adc_value[10] = temp_adc_value.value[2][1]/4;
                    serial_frame.adc_value[11] = temp_adc_value.value[2][2]/4;
              
              #else
                    serial_frame.adc_value[0] = temp_adc_value.cali_value[1][0];
                    serial_frame.adc_value[1] = temp_adc_value.cali_value[1][3];
                    serial_frame.adc_value[2] = temp_adc_value.cali_value[1][1];
                    serial_frame.adc_value[3] = temp_adc_value.cali_value[1][2];
                    
                    serial_frame.adc_value[4] = temp_adc_value.cali_value[0][0];
                    serial_frame.adc_value[5] = temp_adc_value.cali_value[0][3];
                    serial_frame.adc_value[6] = temp_adc_value.cali_value[0][1];
                    serial_frame.adc_value[7] = temp_adc_value.cali_value[0][2];
                    
                    serial_frame.adc_value[8] = temp_adc_value.cali_value[2][0];
                    serial_frame.adc_value[9] = temp_adc_value.cali_value[2][3];
                    serial_frame.adc_value[10] = temp_adc_value.cali_value[2][1];
                    serial_frame.adc_value[11] = temp_adc_value.cali_value[2][2];
              
              #endif
                    
                    serial_frame.checksum = CalChecksum((uint8_t *)&serial_frame, sizeof(serial_frame) - 2);
                    serial_frame.checksum = big_to_small(serial_frame.checksum);
                    
                    send_data((uint8_t *)&serial_frame, sizeof(serial_frame));
C51 COMPILER V9.60.7.0   MAIN                                                              11/03/2023 18:00:24 PAGE 6   

              #endif
 282   3          }
 283   2          
 284   2          
 285   2          delay_ms(1);
 286   2        }
 287   1      }
 288          
 289          //´óÐ¡¶Ë»¥»»
 290          uint16_t big_to_small(uint16_t dat)
 291          {
 292   1        char right, left;
 293   1        uint16_t temp;
 294   1        right = dat & 0XFF;//µÍ°ËÎ»
 295   1        left = dat >> 8;//¸ß°ËÎ»  ÓÒÒÆ8Î»
 296   1        temp = right * 256 + left;
 297   1        
 298   1        return temp;
 299   1      }
 300          
 301          uint16_t CalChecksum(uint8_t * dat, uint16_t len)
 302          {
 303   1          uint16_t sum = 0;
 304   1          uint8_t i = 0;
 305   1          for(i = 0; i < len; ++i)
 306   1          {
 307   2              sum += dat[i];
 308   2          }
 309   1          return sum;
 310   1      }
 311          
 312          /*
 313          ¹¦ÄÜ£ºÑ¡ÔñÐÐµ¼Í¨
 314          ÊäÈë£ºµÚ¼¸ÐÐ
 315          */
 316          void ChooseChanneX(uint8_t dat)
 317          {
 318   1        X_enum x_sort[3] = {X1,X2,X3};
 319   1        
 320   1        #if 1
 321   1        AX1 = (X1==x_sort[dat-1]) ? 0 : 1;
 322   1        AX2 = (X2==x_sort[dat-1]) ? 0 : 1;
 323   1        AX3 = (X3==x_sort[dat-1]) ? 0 : 1; 
 324   1      
 325   1        #else
                AX1 = (X1==x_sort[dat-1]) ? 1 : 0;
                AX2 = (X2==x_sort[dat-1]) ? 1 : 0;
                AX3 = (X3==x_sort[dat-1]) ? 1 : 0; 
                #endif
 330   1      }
 331          
 332          /*
 333          ¹¦ÄÜ£ºÑ¡ÔñÁÐµ¼Í¨
 334          ÊäÈë£ºµÚ¼¸ÐÐ
 335          */
 336          uint8_t ChooseChanneY(uint8_t dat)
 337          {
 338   1        uint8_t AY = 0;
 339   1        Y_enum y_sort[4] = {Y1,Y2,Y3,Y4};
 340   1        
 341   1        switch(y_sort[dat-1])
 342   1        {
C51 COMPILER V9.60.7.0   MAIN                                                              11/03/2023 18:00:24 PAGE 7   

 343   2          case Y1: AY = AY1;
 344   2            break;
 345   2          case Y2: AY = AY2;
 346   2            break;
 347   2          case Y3: AY = AY3;
 348   2            break;
 349   2          case Y4: AY = AY4;
 350   2            break;
 351   2        }
 352   1        
 353   1        return AY;
 354   1      }
 355          
 356          
 357          /*
 358          ¹¦ÄÜ£º»ñÈ¡¾ùÖµÂË²¨ºóµÄÊý¾Ý
 359          ÊäÈë£ºADC²ÉÑùÍ¨µÀ£¬ÂË²¨´ÎÊý
 360          ·µ»Ø£º·µ»ØADCÖµ
 361          */
 362          uint16_t GetAdcValue(uint8_t index,uint8_t count)
 363          {
 364   1        uint8_t i = 0;
 365   1        uint16_t sum = 0;
 366   1         
 367   1        
 368   1        for(i = 0; i < count; ++i)
 369   1        {
 370   2          sum += Get_ADCResult(index);
 371   2          
 372   2        }
 373   1        
 374   1        return sum/count;
 375   1      }
 376          
 377          
 378          /*
 379          ¹¦ÄÜ£ºÐÐÁÐÉ¨Ãè¶ÁÈ¡Êý¾Ý
 380          ÊäÈë£ºÎÞ
 381          ·µ»Ø£º·µ»Ø3*4µÄÊý¾Ý
 382          */
 383          void ReadAdcValue(StuAdcValue *adc_raw_value)
 384          {
 385   1        uint8_t x = 0;
 386   1        uint8_t y = 0;
 387   1        
 388   1        for(x = 0; x <  3; ++x)
 389   1          {
 390   2            ChooseChanneX(x+1);
 391   2            for(y = 0; y < 4; ++y)
 392   2            {
 393   3              adc_raw_value->value[x][y] = GetAdcValue(ChooseChanneY(y+1), 5);
 394   3            }
 395   2          }
 396   1      }
 397          
 398          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1177    ----
   CONSTANT SIZE    =     69    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              11/03/2023 18:00:24 PAGE 8   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     25      76
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
