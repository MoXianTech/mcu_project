C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Firmware) DEBUG PRINT(.\L
                    -istings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include  "config.h"
   2          #include  "STC8G_H_ADC.h"
   3          #include  "STC8G_H_GPIO.h"
   4          #include  "STC8G_H_NVIC.h"
   5          #include  "STC8G_H_Switch.h"
   6          #include  "STC8G_H_Delay.h"
   7          #include  "STC8G_H_UART.h"
   8          
   9          /*Òý½Å¶ÔÓ¦
  10          
  11          ADC²ÉÑùÒý½Å
  12          P3.4  ADC13 ADCA
  13          P1.1  ADC1  ADCB
  14          P3.3  ADC12 ADCC
  15          P1.0  ADC0  ADCD
  16          
  17          XÉ¨ÃèÒý½Å
  18          P1.4  AX1
  19          P1.3  AX2
  20          P1.2  AX3
  21          
  22          LEDÒý½Å
  23          P5.4  LED-W
  24          
  25          ´®¿ÚÒý½Å
  26          P3.0  RX
  27          P3.1  TX
  28          */
  29          
  30          typedef char bool;
  31          
  32          typedef struct {
  33              uint16_t sof;
  34              uint8_t tran_type;
  35              uint16_t len;
  36              uint8_t type;
  37              uint8_t adc_value[3*4];
  38              uint16_t checksum;
  39          } SerialFrame_t;
  40          
  41          
  42          typedef struct 
  43          {
  44            uint16_t value[3][4];
  45          }StuAdcValue;
  46          
  47          typedef enum {
  48            X1 = 1,
  49            X2,
  50            X3
  51          }X_enum;
  52          
  53          typedef enum{
  54            Y1 = 1,
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 2   

  55            Y2,
  56            Y3,
  57            Y4,
  58          }Y_enum;
  59          
  60          #define LOG_PRINTF 0
  61          
  62          #define AY1 ADC_CH12
  63          #define AY2 ADC_CH1
  64          #define AY3 ADC_CH0
  65          #define AY4 ADC_CH11
  66          
  67          sbit AX1 = P1^4;
  68          sbit AX2 = P1^3;
  69          sbit AX3 = P1^2;
  70          
  71          sbit LED = P5^4;
  72          
  73          uint32_t time_1ms = 0;
  74          #if LOG_PRINTF
              uint8_t printf_buffer[20] = {0};
              
              #else
  78          SerialFrame_t serial_frame;
  79          #endif
  80          StuAdcValue temp_adc_value;
  81          
  82          
  83          void ReadAdcValue(StuAdcValue *adc_raw_value);
  84          uint16_t CalChecksum(uint8_t * dat, uint16_t len);
  85          uint16_t big_to_small(uint16_t dat);
  86          
  87          /************************ IO¿ÚÅäÖÃ ****************************/
  88          void  GPIO_config(void)
  89          {
  90   1        GPIO_InitTypeDef  GPIO_InitStructure;         //½á¹¹¶¨Òå
  91   1        GPIO_InitStructure.Pin  = GPIO_Pin_0|GPIO_Pin_1;           //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO_Pin_7, »
             -ò²Ù×÷
  92   1        GPIO_InitStructure.Mode = GPIO_HighZ;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_O
             -D,GPIO_OUT_PP
  93   1        GPIO_Inilize(GPIO_P1,&GPIO_InitStructure);      //³õÊ¼»¯
  94   1      
  95   1        GPIO_InitStructure.Pin  = GPIO_Pin_3|GPIO_Pin_4;         //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO_Pin_7, »ò²
             -Ù×÷
  96   1        GPIO_InitStructure.Mode = GPIO_HighZ;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_O
             -D,GPIO_OUT_PP
  97   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);      //³õÊ¼»¯
  98   1        
  99   1        GPIO_InitStructure.Pin  = GPIO_Pin_0|GPIO_Pin_1;         //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO_Pin_7, »ò²
             -Ù×÷
 100   1        GPIO_InitStructure.Mode = GPIO_OUT_PP;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
             -OD,GPIO_OUT_PP
 101   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);      //³õÊ¼»¯
 102   1        
 103   1        GPIO_InitStructure.Pin  = GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4;         //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO
             -_Pin_7, »ò²Ù×÷
 104   1        GPIO_InitStructure.Mode = GPIO_OUT_PP;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
             -OD,GPIO_OUT_PP
 105   1        GPIO_Inilize(GPIO_P1,&GPIO_InitStructure);      //³õÊ¼»¯
 106   1        
 107   1        GPIO_InitStructure.Pin  = GPIO_Pin_4;         //Ö¸¶¨Òª³õÊ¼»¯µÄIO, GPIO_Pin_0 ~ GPIO_Pin_7, »ò²Ù×÷
 108   1        GPIO_InitStructure.Mode = GPIO_PullUp;          //Ö¸¶¨IOµÄÊäÈë»òÊä³ö·½Ê½,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 3   

             -OD,GPIO_OUT_PP
 109   1        GPIO_Inilize(GPIO_P5,&GPIO_InitStructure);      //³õÊ¼»¯
 110   1      }
 111          
 112          
 113          /******************* ADÅäÖÃº¯Êý *******************/
 114          void  ADC_config(void)
 115          {
 116   1        ADC_InitTypeDef   ADC_InitStructure;    //½á¹¹¶¨Òå
 117   1      
 118   1        ADC_InitStructure.ADC_SMPduty   = 31;   //ADC Ä£ÄâÐÅºÅ²ÉÑùÊ±¼ä¿ØÖÆ, 0~31£¨×¢Òâ£º SMPDUTY Ò»¶¨²»ÄÜÉèÖÃÐ¡ÓÚ 
             -10£©
 119   1        ADC_InitStructure.ADC_CsSetup   = 0;    //ADC Í¨µÀÑ¡ÔñÊ±¼ä¿ØÖÆ 0(Ä¬ÈÏ),1
 120   1        ADC_InitStructure.ADC_CsHold    = 1;    //ADC Í¨µÀÑ¡Ôñ±£³ÖÊ±¼ä¿ØÖÆ 0,1(Ä¬ÈÏ),2,3
 121   1        ADC_InitStructure.ADC_Speed     = ADC_SPEED_2X16T;    //ÉèÖÃ ADC ¹¤×÷Ê±ÖÓÆµÂÊ ADC_SPEED_2X1T~ADC_SPEED_2X16
             -T
 122   1        ADC_InitStructure.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;  //ADC½á¹ûµ÷Õû,  ADC_LEFT_JUSTIFIED,ADC_RIGHT_JUSTIF
             -IED
 123   1        ADC_Inilize(&ADC_InitStructure);    //³õÊ¼»¯
 124   1        ADC_PowerControl(ENABLE);       //ADCµçÔ´¿ª¹Ø, ENABLE»òDISABLE
 125   1        NVIC_ADC_Init(DISABLE,Priority_0);    //ÖÐ¶ÏÊ¹ÄÜ, ENABLE/DISABLE; ÓÅÏÈ¼¶(µÍµ½¸ß) Priority_0,Priority_1,Prio
             -rity_2,Priority_3
 126   1      }
 127          
 128          
 129          /***************  ´®¿Ú³õÊ¼»¯º¯Êý *****************/
 130          void  UART_config(void)
 131          {
 132   1        COMx_InitDefine   COMx_InitStructure;         //½á¹¹¶¨Òå
 133   1      
 134   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;   //Ä£Ê½,   UART_ShiftRight,UART_8bit_BRTx,UART_9bit,U
             -ART_9bit_BRTx
 135   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;     //Ñ¡Ôñ²¨ÌØÂÊ·¢ÉúÆ÷, BRT_Timer2 (×¢Òâ: ´®¿Ú2¹Ì¶¨Ê¹ÓÃBRT_
             -Timer2, ËùÒÔ²»ÓÃÑ¡Ôñ)
 136   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //²¨ÌØÂÊ,     110 ~ 115200
 137   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //½ÓÊÕÔÊÐí,   ENABLE»òDISABLE
 138   1        UART_Configuration(UART1, &COMx_InitStructure);   //³õÊ¼»¯´®¿Ú2 USART1,USART2,USART3,USART4
 139   1        NVIC_UART1_Init(ENABLE,Priority_1);   //ÖÐ¶ÏÊ¹ÄÜ, ENABLE/DISABLE; ÓÅÏÈ¼¶(µÍµ½¸ß) Priority_0,Priority_1,Pri
             -ority_2,Priority_3
 140   1        UART1_SW(UART1_SW_P30_P31);   //UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44
 141   1      }
 142          
 143          
 144          /************************** Ö÷º¯Êý**********************/
 145          void main(void)
 146          {
 147   1        static bool led_flag = FALSE;
 148   1      
 149   1      
 150   1        uint8_t i = 0;
 151   1        
 152   1        EAXSFR();
 153   1        GPIO_config();
 154   1        UART_config();
 155   1        ADC_config();
 156   1        EA = 1;
 157   1        
 158   1        while(1)
 159   1        {
 160   2          time_1ms ++;
 161   2              //LEDÉÁË¸
 162   2          if(time_1ms % 500 == 0)
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 4   

 163   2          {
 164   3            led_flag = !led_flag;
 165   3            LED = led_flag;
 166   3          }
 167   2          
 168   2          if(time_1ms % 14 == 0)
 169   2          {
 170   3            ReadAdcValue(&temp_adc_value);
 171   3            
 172   3          }
 173   2          if(time_1ms %14 == 0)
 174   2          {
 175   3       //Êý¾ÝÅÅÁÐ×ª»»
 176   3      #if LOG_PRINTF
                    sprintf(printf_buffer, "adc_value = %u",temp_adc_value.value[0][0]);
                    PrintString1(printf_buffer);
                    sprintf(printf_buffer, " %u",temp_adc_value.value[1][4]);
                    PrintString1(printf_buffer);
                    sprintf(printf_buffer, " %u\r\n",temp_adc_value.value[2][0]);
                    PrintString1(printf_buffer);
              #else     
 184   3            serial_frame.sof = 0xa55a;
 185   3            serial_frame.tran_type = 0x01;
 186   3            serial_frame.len = big_to_small(sizeof(serial_frame) - 2)
 187   3              ;
 188   3            serial_frame.type = 0x01;
 189   3            
 190   3            serial_frame.adc_value[0] = temp_adc_value.value[1][0];
 191   3            serial_frame.adc_value[1] = temp_adc_value.value[1][3];
 192   3            serial_frame.adc_value[2] = temp_adc_value.value[1][1];
 193   3            serial_frame.adc_value[3] = temp_adc_value.value[1][2];
 194   3            
 195   3            serial_frame.adc_value[4] = temp_adc_value.value[0][0];
 196   3            serial_frame.adc_value[5] = temp_adc_value.value[0][3];
 197   3            serial_frame.adc_value[6] = temp_adc_value.value[0][1];
 198   3            serial_frame.adc_value[7] = temp_adc_value.value[0][2];
 199   3            
 200   3            serial_frame.adc_value[8] = temp_adc_value.value[2][0];
 201   3            serial_frame.adc_value[9] = temp_adc_value.value[2][3];
 202   3            serial_frame.adc_value[10] = temp_adc_value.value[2][1];
 203   3            serial_frame.adc_value[11] = temp_adc_value.value[2][2];
 204   3            
 205   3            serial_frame.checksum = CalChecksum((uint8_t *)&serial_frame, sizeof(serial_frame) - 2);
 206   3            serial_frame.checksum = big_to_small(serial_frame.checksum);
 207   3            
 208   3            send_data((uint8_t *)&serial_frame,sizeof(serial_frame));
 209   3            
 210   3      #endif
 211   3          }
 212   2          
 213   2          
 214   2          delay_ms(1);
 215   2        }
 216   1      }
 217          
 218          //´óÐ¡¶Ë»¥»»
 219          uint16_t big_to_small(uint16_t dat)
 220          {
 221   1        char right, left;
 222   1        uint16_t temp;
 223   1        right = dat & 0XFF;//µÍ°ËÎ»
 224   1        left = dat >> 8;//¸ß°ËÎ»  ÓÒÒÆ8Î»
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 5   

 225   1        temp = right * 256 + left;
 226   1        
 227   1        return temp;
 228   1      }
 229          
 230          uint16_t CalChecksum(uint8_t * dat, uint16_t len)
 231          {
 232   1          uint16_t sum = 0;
 233   1          uint8_t i = 0;
 234   1          for(i = 0; i < len; ++i)
 235   1          {
 236   2              sum += dat[i];
 237   2          }
 238   1          return sum;
 239   1      }
 240          
 241          /*
 242          ¹¦ÄÜ£ºÑ¡ÔñÐÐµ¼Í¨
 243          ÊäÈë£ºµÚ¼¸ÐÐ
 244          */
 245          void ChooseChanneX(uint8_t dat)
 246          {
 247   1        X_enum x_sort[3] = {X1,X2,X3};
 248   1        
 249   1        AX1 = (X1==x_sort[dat-1]) ? 1 : 0;
 250   1        AX2 = (X2==x_sort[dat-1]) ? 1 : 0;
 251   1        AX3 = (X3==x_sort[dat-1]) ? 1 : 0; 
 252   1      }
 253          
 254          /*
 255          ¹¦ÄÜ£ºÑ¡ÔñÁÐµ¼Í¨
 256          ÊäÈë£ºµÚ¼¸ÐÐ
 257          */
 258          uint8_t ChooseChanneY(uint8_t dat)
 259          {
 260   1        uint8_t AY = 0;
 261   1        Y_enum y_sort[4] = {Y1,Y2,Y3,Y4};
 262   1        
 263   1        switch(y_sort[dat-1])
 264   1        {
 265   2          case Y1: AY = AY1;
 266   2            break;
 267   2          case Y2: AY = AY2;
 268   2            break;
 269   2          case Y3: AY = AY3;
 270   2            break;
 271   2          case Y4: AY = AY4;
 272   2            break;
 273   2        }
 274   1        
 275   1        return AY;
 276   1      }
 277          
 278          
 279          /*
 280          ¹¦ÄÜ£º»ñÈ¡¾ùÖµÂË²¨ºóµÄÊý¾Ý
 281          ÊäÈë£ºADC²ÉÑùÍ¨µÀ£¬ÂË²¨´ÎÊý
 282          ·µ»Ø£º·µ»ØADCÖµ
 283          */
 284          uint16_t GetAdcValue(uint8_t index,uint8_t count)
 285          {
 286   1        uint8_t i = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 6   

 287   1        uint16_t sum = 0;
 288   1         
 289   1        
 290   1        for(i = 0; i < count; ++i)
 291   1        {
 292   2          sum += Get_ADCResult(index);
 293   2          
 294   2        }
 295   1        
 296   1        return sum/count;
 297   1      }
 298          
 299          
 300          /*
 301          ¹¦ÄÜ£ºÐÐÁÐÉ¨Ãè¶ÁÈ¡Êý¾Ý
 302          ÊäÈë£ºÎÞ
 303          ·µ»Ø£º·µ»Ø3*4µÄÊý¾Ý
 304          */
 305          void ReadAdcValue(StuAdcValue *adc_raw_value)
 306          {
 307   1        uint8_t x = 0;
 308   1        uint8_t y = 0;
 309   1        
 310   1        for(x = 0; x <  3; ++x)
 311   1          {
 312   2            ChooseChanneX(x+1);
 313   2            for(y = 0; y < 4; ++y)
 314   2            {
 315   3              adc_raw_value->value[x][y] = GetAdcValue(ChooseChanneY(y+1),5)/4;
 316   3            }
 317   2          }
 318   1      }
 319          
 320          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    786    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49      44
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
