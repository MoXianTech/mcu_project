C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Firmware) DEBUG PRINT(.\L
                    -istings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include  "config.h"
   2          #include  "STC8G_H_ADC.h"
   3          #include  "STC8G_H_GPIO.h"
   4          #include  "STC8G_H_NVIC.h"
   5          #include  "STC8G_H_Switch.h"
   6          #include  "STC8G_H_Delay.h"
   7          #include  "STC8G_H_UART.h"
   8          
   9          /*“˝Ω≈∂‘”¶
  10          
  11          ADC≤…—˘“˝Ω≈
  12          P3.4  ADC13 ADCA
  13          P1.1  ADC1  ADCB
  14          P3.3  ADC12 ADCC
  15          P1.0  ADC0  ADCD
  16          
  17          X…®√Ë“˝Ω≈
  18          P1.4  AX1
  19          P1.3  AX2
  20          P1.2  AX3
  21          
  22          LED“˝Ω≈
  23          P5.4  LED-W
  24          
  25          ¥Æø⁄“˝Ω≈
  26          P3.0  RX
  27          P3.1  TX
  28          */
  29          
  30          typedef char bool;
  31          
  32          typedef struct {
  33              uint16_t sof;
  34              uint8_t tran_type;
  35              uint16_t len;
  36              uint8_t type;
  37              uint8_t adc_value[3*4];
  38              uint16_t checksum;
  39          } SerialFrame_t;
  40          
  41          
  42          typedef struct 
  43          {
  44            uint16_t value[3][4];
  45          }StuAdcValue;
  46          
  47          typedef enum {
  48            X1 = 1,
  49            X2,
  50            X3
  51          }X_enum;
  52          
  53          typedef enum{
  54            Y1 = 1,
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 2   

  55            Y2,
  56            Y3,
  57            Y4,
  58          }Y_enum;
  59          
  60          #define LOG_PRINTF 0
  61          
  62          #define AY1 ADC_CH12
  63          #define AY2 ADC_CH1
  64          #define AY3 ADC_CH0
  65          #define AY4 ADC_CH11
  66          
  67          sbit AX1 = P1^4;
  68          sbit AX2 = P1^3;
  69          sbit AX3 = P1^2;
  70          
  71          sbit LED = P5^4;
  72          
  73          uint32_t time_1ms = 0;
  74          #if LOG_PRINTF
              uint8_t printf_buffer[20] = {0};
              
              #else
  78          SerialFrame_t serial_frame;
  79          #endif
  80          StuAdcValue temp_adc_value;
  81          
  82          
  83          void ReadAdcValue(StuAdcValue *adc_raw_value);
  84          uint16_t CalChecksum(uint8_t * dat, uint16_t len);
  85          uint16_t big_to_small(uint16_t dat);
  86          
  87          /************************ IOø⁄≈‰÷√ ****************************/
  88          void  GPIO_config(void)
  89          {
  90   1        GPIO_InitTypeDef  GPIO_InitStructure;         //Ω·ππ∂®“Â
  91   1        GPIO_InitStructure.Pin  = GPIO_Pin_0|GPIO_Pin_1;           //÷∏∂®“™≥ı ºªØµƒIO, GPIO_Pin_0 ~ GPIO_Pin_7, ª
             -Ú≤Ÿ◊˜
  92   1        GPIO_InitStructure.Mode = GPIO_HighZ;          //÷∏∂®IOµƒ ‰»ÎªÚ ‰≥ˆ∑Ω Ω,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_O
             -D,GPIO_OUT_PP
  93   1        GPIO_Inilize(GPIO_P1,&GPIO_InitStructure);      //≥ı ºªØ
  94   1      
  95   1        GPIO_InitStructure.Pin  = GPIO_Pin_3|GPIO_Pin_4;         //÷∏∂®“™≥ı ºªØµƒIO, GPIO_Pin_0 ~ GPIO_Pin_7, ªÚ≤
             -Ÿ◊˜
  96   1        GPIO_InitStructure.Mode = GPIO_HighZ;          //÷∏∂®IOµƒ ‰»ÎªÚ ‰≥ˆ∑Ω Ω,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_O
             -D,GPIO_OUT_PP
  97   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);      //≥ı ºªØ
  98   1        
  99   1        GPIO_InitStructure.Pin  = GPIO_Pin_0|GPIO_Pin_1;         //÷∏∂®“™≥ı ºªØµƒIO, GPIO_Pin_0 ~ GPIO_Pin_7, ªÚ≤
             -Ÿ◊˜
 100   1        GPIO_InitStructure.Mode = GPIO_OUT_PP;          //÷∏∂®IOµƒ ‰»ÎªÚ ‰≥ˆ∑Ω Ω,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
             -OD,GPIO_OUT_PP
 101   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);      //≥ı ºªØ
 102   1        
 103   1        GPIO_InitStructure.Pin  = GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4;         //÷∏∂®“™≥ı ºªØµƒIO, GPIO_Pin_0 ~ GPIO
             -_Pin_7, ªÚ≤Ÿ◊˜
 104   1        GPIO_InitStructure.Mode = GPIO_OUT_PP;          //÷∏∂®IOµƒ ‰»ÎªÚ ‰≥ˆ∑Ω Ω,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
             -OD,GPIO_OUT_PP
 105   1        GPIO_Inilize(GPIO_P1,&GPIO_InitStructure);      //≥ı ºªØ
 106   1        
 107   1        GPIO_InitStructure.Pin  = GPIO_Pin_4;         //÷∏∂®“™≥ı ºªØµƒIO, GPIO_Pin_0 ~ GPIO_Pin_7, ªÚ≤Ÿ◊˜
 108   1        GPIO_InitStructure.Mode = GPIO_PullUp;          //÷∏∂®IOµƒ ‰»ÎªÚ ‰≥ˆ∑Ω Ω,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 3   

             -OD,GPIO_OUT_PP
 109   1        GPIO_Inilize(GPIO_P5,&GPIO_InitStructure);      //≥ı ºªØ
 110   1      }
 111          
 112          
 113          /******************* AD≈‰÷√∫Ø ˝ *******************/
 114          void  ADC_config(void)
 115          {
 116   1        ADC_InitTypeDef   ADC_InitStructure;    //Ω·ππ∂®“Â
 117   1      
 118   1        ADC_InitStructure.ADC_SMPduty   = 31;   //ADC ƒ£ƒ‚–≈∫≈≤…—˘ ±º‰øÿ÷∆, 0~31£®◊¢“‚£∫ SMPDUTY “ª∂®≤ªƒ‹…Ë÷√–°”⁄ 
             -10£©
 119   1        ADC_InitStructure.ADC_CsSetup   = 0;    //ADC Õ®µ¿—°‘Ò ±º‰øÿ÷∆ 0(ƒ¨»œ),1
 120   1        ADC_InitStructure.ADC_CsHold    = 1;    //ADC Õ®µ¿—°‘Ò±£≥÷ ±º‰øÿ÷∆ 0,1(ƒ¨»œ),2,3
 121   1        ADC_InitStructure.ADC_Speed     = ADC_SPEED_2X16T;    //…Ë÷√ ADC π§◊˜ ±÷”∆µ¬  ADC_SPEED_2X1T~ADC_SPEED_2X16
             -T
 122   1        ADC_InitStructure.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;  //ADCΩ·π˚µ˜’˚,  ADC_LEFT_JUSTIFIED,ADC_RIGHT_JUSTIF
             -IED
 123   1        ADC_Inilize(&ADC_InitStructure);    //≥ı ºªØ
 124   1        ADC_PowerControl(ENABLE);       //ADCµÁ‘¥ø™πÿ, ENABLEªÚDISABLE
 125   1        NVIC_ADC_Init(DISABLE,Priority_0);    //÷–∂œ πƒ‹, ENABLE/DISABLE; ”≈œ»º∂(µÕµΩ∏ﬂ) Priority_0,Priority_1,Prio
             -rity_2,Priority_3
 126   1      }
 127          
 128          
 129          /***************  ¥Æø⁄≥ı ºªØ∫Ø ˝ *****************/
 130          void  UART_config(void)
 131          {
 132   1        COMx_InitDefine   COMx_InitStructure;         //Ω·ππ∂®“Â
 133   1      
 134   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;   //ƒ£ Ω,   UART_ShiftRight,UART_8bit_BRTx,UART_9bit,U
             -ART_9bit_BRTx
 135   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;     //—°‘Ò≤®Ãÿ¬ ∑¢…˙∆˜, BRT_Timer2 (◊¢“‚: ¥Æø⁄2πÃ∂® π”√BRT_
             -Timer2, À˘“‘≤ª”√—°‘Ò)
 136   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //≤®Ãÿ¬ ,     110 ~ 115200
 137   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //Ω” ’‘ –Ì,   ENABLEªÚDISABLE
 138   1        UART_Configuration(UART1, &COMx_InitStructure);   //≥ı ºªØ¥Æø⁄2 USART1,USART2,USART3,USART4
 139   1        NVIC_UART1_Init(ENABLE,Priority_1);   //÷–∂œ πƒ‹, ENABLE/DISABLE; ”≈œ»º∂(µÕµΩ∏ﬂ) Priority_0,Priority_1,Pri
             -ority_2,Priority_3
 140   1        UART1_SW(UART1_SW_P30_P31);   //UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44
 141   1      }
 142          
 143          
 144          /************************** ÷˜∫Ø ˝**********************/
 145          void main(void)
 146          {
 147   1        static bool led_flag = FALSE;
 148   1      
 149   1      
 150   1        uint8_t i = 0;
 151   1        
 152   1        EAXSFR();
 153   1        GPIO_config();
 154   1        UART_config();
 155   1        ADC_config();
 156   1        EA = 1;
 157   1        
 158   1        while(1)
 159   1        {
 160   2          time_1ms ++;
 161   2              //LED…¡À∏
 162   2          if(time_1ms % 500 == 0)
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 4   

 163   2          {
 164   3            led_flag = !led_flag;
 165   3            LED = led_flag;
 166   3          }
 167   2          
 168   2          if(time_1ms % 14 == 0)
 169   2          {
 170   3            ReadAdcValue(&temp_adc_value);
 171   3            
 172   3          }
 173   2          if(time_1ms %14 == 0)
 174   2          {
 175   3       // ˝æ›≈≈¡–◊™ªª
 176   3      #if LOG_PRINTF
                    sprintf(printf_buffer, "adc_value = %u",temp_adc_value.value[0][0]);
                    PrintString1(printf_buffer);
                    sprintf(printf_buffer, " %u",temp_adc_value.value[1][4]);
                    PrintString1(printf_buffer);
                    sprintf(printf_buffer, " %u\r\n",temp_adc_value.value[2][0]);
                    PrintString1(printf_buffer);
              #else     
 184   3            serial_frame.sof = 0xa55a;
 185   3            serial_frame.tran_type = 0x01;
 186   3            serial_frame.len = big_to_small(sizeof(serial_frame) - 2)
 187   3              ;
 188   3            serial_frame.type = 0x01;
 189   3            
 190   3            serial_frame.adc_value[0] = temp_adc_value.value[1][0];
 191   3            serial_frame.adc_value[1] = temp_adc_value.value[1][3];
 192   3            serial_frame.adc_value[2] = temp_adc_value.value[1][1];
 193   3            serial_frame.adc_value[3] = temp_adc_value.value[1][2];
 194   3            
 195   3            serial_frame.adc_value[4] = temp_adc_value.value[0][0];
 196   3            serial_frame.adc_value[5] = temp_adc_value.value[0][3];
 197   3            serial_frame.adc_value[6] = temp_adc_value.value[0][1];
 198   3            serial_frame.adc_value[7] = temp_adc_value.value[0][2];
 199   3            
 200   3            serial_frame.adc_value[8] = temp_adc_value.value[2][0];
 201   3            serial_frame.adc_value[9] = temp_adc_value.value[2][3];
 202   3            serial_frame.adc_value[10] = temp_adc_value.value[2][1];
 203   3            serial_frame.adc_value[11] = temp_adc_value.value[2][2];
 204   3            
 205   3            serial_frame.checksum = CalChecksum((uint8_t *)&serial_frame, sizeof(serial_frame) - 2);
 206   3            serial_frame.checksum = big_to_small(serial_frame.checksum);
 207   3            
 208   3            send_data((uint8_t *)&serial_frame,sizeof(serial_frame));
 209   3            
 210   3      #endif
 211   3          }
 212   2          
 213   2          
 214   2          delay_ms(1);
 215   2        }
 216   1      }
 217          
 218          //¥Û–°∂Àª•ªª
 219          uint16_t big_to_small(uint16_t dat)
 220          {
 221   1        char right, left;
 222   1        uint16_t temp;
 223   1        right = dat & 0XFF;//µÕ∞ÀŒª
 224   1        left = dat >> 8;//∏ﬂ∞ÀŒª  ”““∆8Œª
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 5   

 225   1        temp = right * 256 + left;
 226   1        
 227   1        return temp;
 228   1      }
 229          
 230          uint16_t CalChecksum(uint8_t * dat, uint16_t len)
 231          {
 232   1          uint16_t sum = 0;
 233   1          uint8_t i = 0;
 234   1          for(i = 0; i < len; ++i)
 235   1          {
 236   2              sum += dat[i];
 237   2          }
 238   1          return sum;
 239   1      }
 240          
 241          /*
 242          π¶ƒ‹£∫—°‘Ò––µºÕ®
 243           ‰»Î£∫µ⁄º∏––
 244          */
 245          void ChooseChanneX(uint8_t dat)
 246          {
 247   1        X_enum x_sort[3] = {X1,X2,X3};
 248   1        
 249   1        AX1 = (X1==x_sort[dat-1]) ? 1 : 0;
 250   1        AX2 = (X2==x_sort[dat-1]) ? 1 : 0;
 251   1        AX3 = (X3==x_sort[dat-1]) ? 1 : 0; 
 252   1      }
 253          
 254          /*
 255          π¶ƒ‹£∫—°‘Ò¡–µºÕ®
 256           ‰»Î£∫µ⁄º∏––
 257          */
 258          uint8_t ChooseChanneY(uint8_t dat)
 259          {
 260   1        uint8_t AY = 0;
 261   1        Y_enum y_sort[4] = {Y1,Y2,Y3,Y4};
 262   1        
 263   1        switch(y_sort[dat-1])
 264   1        {
 265   2          case Y1: AY = AY1;
 266   2            break;
 267   2          case Y2: AY = AY2;
 268   2            break;
 269   2          case Y3: AY = AY3;
 270   2            break;
 271   2          case Y4: AY = AY4;
 272   2            break;
 273   2        }
 274   1        
 275   1        return AY;
 276   1      }
 277          
 278          
 279          /*
 280          π¶ƒ‹£∫ªÒ»°æ˘÷µ¬À≤®∫Ûµƒ ˝æ›
 281           ‰»Î£∫ADC≤…—˘Õ®µ¿£¨¬À≤®¥Œ ˝
 282          ∑µªÿ£∫∑µªÿADC÷µ
 283          */
 284          uint16_t GetAdcValue(uint8_t index,uint8_t count)
 285          {
 286   1        uint8_t i = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              10/31/2023 12:21:41 PAGE 6   

 287   1        uint16_t sum = 0;
 288   1         
 289   1        
 290   1        for(i = 0; i < count; ++i)
 291   1        {
 292   2          sum += Get_ADCResult(index);
 293   2          
 294   2        }
 295   1        
 296   1        return sum/count;
 297   1      }
 298          
 299          
 300          /*
 301          π¶ƒ‹£∫––¡–…®√Ë∂¡»° ˝æ›
 302           ‰»Î£∫Œﬁ
 303          ∑µªÿ£∫∑µªÿ3*4µƒ ˝æ›
 304          */
 305          void ReadAdcValue(StuAdcValue *adc_raw_value)
 306          {
 307   1        uint8_t x = 0;
 308   1        uint8_t y = 0;
 309   1        
 310   1        for(x = 0; x <  3; ++x)
 311   1          {
 312   2            ChooseChanneX(x+1);
 313   2            for(y = 0; y < 4; ++y)
 314   2            {
 315   3              adc_raw_value->value[x][y] = GetAdcValue(ChooseChanneY(y+1),5)/4;
 316   3            }
 317   2          }
 318   1      }
 319          
 320          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    786    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49      44
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
